<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>リアルタイム物体検知</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #canvasContainer {
            width: 100%;
            height: 80vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }
        #canvas {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
        #cameraSwitch, #status, #error {
            margin-top: 10px;
        }
        #status {
            color: blue;
        }
        #error {
            color: red;
        }
    </style>
</head>
<body>
    <h1>リアルタイム物体検知</h1>
    <div id="canvasContainer">
        <canvas id="canvas"></canvas>
    </div>
    <button id="cameraSwitch">カメラを切り替え</button>
    <div id="status"></div>
    <div id="error"></div>

    <script>
        const video = document.createElement('video');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const statusDiv = document.getElementById('status');
        const errorDiv = document.getElementById('error');
        const cameraSwitchBtn = document.getElementById('cameraSwitch');
        let currentFacingMode = 'environment';
        let model;

        function updateStatus(message) {
            statusDiv.textContent = message;
        }

        function showError(message) {
            errorDiv.textContent = message;
        }

        async function setupCamera() {
            updateStatus("カメラを起動中...");
            const constraints = {
                video: {
                    facingMode: currentFacingMode,
                    width: { ideal: 1280 },
                    height: { ideal: 720 }
                }
            };

            try {
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = stream;
                await new Promise((resolve) => {
                    video.onloadedmetadata = () => {
                        resolve(video);
                    };
                });
                video.play();
                updateCanvasSize();
                updateStatus("カメラ起動完了。物体検知を開始します。");
                runDetection();
            } catch (err) {
                console.error("カメラの起動に失敗しました: ", err);
                showError(`カメラの起動エラー: ${err.name} - ${err.message}`);
            }
        }

        function updateCanvasSize() {
            const containerWidth = canvas.parentElement.clientWidth;
            const containerHeight = canvas.parentElement.clientHeight;
            const videoAspectRatio = video.videoWidth / video.videoHeight;
            const containerAspectRatio = containerWidth / containerHeight;

            if (videoAspectRatio > containerAspectRatio) {
                canvas.width = containerWidth;
                canvas.height = containerWidth / videoAspectRatio;
            } else {
                canvas.height = containerHeight;
                canvas.width = containerHeight * videoAspectRatio;
            }
        }

        cameraSwitchBtn.onclick = async () => {
            if (video.srcObject) {
                video.srcObject.getTracks().forEach(track => track.stop());
            }
            currentFacingMode = currentFacingMode === 'environment' ? 'user' : 'environment';
            await setupCamera();
        };

        async function loadModelAndDetect() {
            try {
                updateStatus("モデルを読み込み中...");
                model = await cocoSsd.load();
                updateStatus("モデル読み込み完了。カメラを起動します。");
                await setupCamera();
            } catch (err) {
                console.error("モデルの読み込みに失敗しました: ", err);
                showError(`モデル読み込みエラー: ${err.message}`);
            }
        }

        async function runDetection() {
            if (!model) return;
            try {
                const predictions = await model.detect(video);
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                
                if (predictions.length === 0) {
                    updateStatus("物体が検出されません");
                } else {
                    updateStatus(`${predictions.length}個の物体を検出`);
                }

                predictions.forEach(prediction => {
                    const [x, y, width, height] = prediction.bbox;
                    const scaledX = x * (canvas.width / video.videoWidth);
                    const scaledY = y * (canvas.height / video.videoHeight);
                    const scaledWidth = width * (canvas.width / video.videoWidth);
                    const scaledHeight = height * (canvas.height / video.videoHeight);

                    ctx.strokeStyle = '#00FFFF';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(scaledX, scaledY, scaledWidth, scaledHeight);
                    
                    ctx.fillStyle = '#00FFFF';
                    ctx.font = '16px Arial';
                    ctx.fillText(`${prediction.class} (${Math.round(prediction.score * 100)}%)`, scaledX, scaledY > 10 ? scaledY - 5 : 10);
                });
                requestAnimationFrame(runDetection);
            } catch (err) {
                console.error("物体検知中にエラーが発生しました: ", err);
                showError(`物体検知エラー: ${err.message}`);
            }
        }

        window.addEventListener('resize', updateCanvasSize);
        window.addEventListener('orientationchange', updateCanvasSize);

        loadModelAndDetect();
    </script>
</body>
</html>
